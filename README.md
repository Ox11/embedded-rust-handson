# Embedded Rust Hands-On

## Goal

This hands-on shall help starting a new Rust project on a micro controller that does not have an entire community behind a single core or even board.
A standard STM32 micro controller is chosen, where work is needed.
On the other side, we do not want to debug hardware problems.
For that, an eval board with spark fun sensors is likely a good choice.

The build environment shall be natively on Windows as the advantage of the better linux integration comes with a more complex hardware connection setup.

## Perquisites

### Software

- [ ] Windows system
- [ ] VS code with plugins. 
  You can install recommended plugins provided by the [extensions.json](.vscode/extensions.json)
- [ ] Git client (just to clone this repository)

### Hardware 

- [x] STM32L412KB Eval Board (Arduino Nano)
  - (Default) Connected SB18 solder bridge for Arduino Nano I2C configuration
- [x] SparkFun Qwiic adapter board (Arduino Nano)
- [x] SparkFun TPM102 temperature sensor
- [x] Qwiic cable

## Installation

### Required Tools

- Install __Rust__ and configure it for the GNU toolchain (alternatively if you have a Visual Studio License you may also use the default):
  To do, you can use the easy installer <https://github.com/hastur-dev/rs-easy-installer-windows>.
  which installs MSYS2 for the GNU-Toolchain and configures rust to use it as default
- Install __ARM Compiler__ (check add to path at the end) <https://developer.arm.com/-/media/Files/downloads/gnu/14.3.rel1/binrel/arm-gnu-toolchain-14.3.rel1-mingw-w64-x86_64-arm-none-eabi.exe>
- Install __ST Link__ (`dpinst_amd64.exe`) <https://www.st.com/en/development-tools/stsw-link009.html#get-software>  
- Install __Probe-rs__ (An alternative to OpenOCD)

  ```ps
  powershell -ExecutionPolicy Bypass -c "irm https://github.com/probe-rs/probe-rs/releases/latest/download/probe-rs-tools-installer.ps1 | iex"
  ``` 

### Configuring Rust Toolchain

- Add rust cross-compile target for stm32l4  
  
  ```ps
  rustup target add thumbv7em-none-eabihf
  ``` 

- (Optionally) Add binutils to [inspect the binary file](#inspect-binary)
  
  ```ps
  rustup component add llvm-tools-preview
  cargo install cargo-binutils
  ```

## Project Setup

Now you are ready to start your own embedded project
1. Create a new Project 

  ```ps
  cargo.exe new <Project-Name>
  ```

2. Create a rust program that prints hello world via debugger to the console
   1. Add your `.cargo/config.toml` for your project settings

      ```toml
      [build]
      # Set default target
      target = "thumbv7em-none-eabihf" # Cortex-M4F with FPU

      [target.thumbv7em-none-eabihf]
      # Target specific settings
      linker = "arm-none-eabi-ld"
      ar = "arm-none-eabi-ar"
      runner = "probe-rs run --chip STM32L412KBUx"
      rustflags = [
        "-C", "target-cpu=cortex-m4", # set target CPU
        "-C", "link-arg=-Tlink.x", # use autogenerated linker file
        "-C", "link-arg=-Tdefmt.x", # use defmt linker file
      ]
      ```

   2. Edit your minimal `main.rs` file

        ```rust
        #![no_std]
        #![no_main]

        // Used only to link correctly, ignore unused warning
        use embassy_stm32;

        // default panic handler
        use panic_probe as _;

        // Required for logging. defmt is short for deferred formatting
        use defmt::*;
        use defmt_rtt as _;

        // Required for Task like async programming
        use embassy_executor::Spawner;

        #[embassy_executor::main]
        async fn main(_spawner: Spawner) -> ! {

            println!("-------------------- uC Startup --------------------");
            info!("Hello World from my Nucleo board");
            warn!("Actually not that critical");
            error!("Actually not not even an error");

            loop {
                // Nothing to do
            }
        }
      ```

   3. Install the reference libraries named crates or add them manually to the `Cargo.toml` and enable the required features

      ```toml
      [dependencies]
      cortex-m = { version = "0.7.6", features = ["critical-section-single-core"] }
      cortex-m-rt = "0.7.5"
      defmt = "1.0.1"
      defmt-rtt = "1.0.0"
      panic-probe = "1.0.0"
      # to use autogenerated linker file, enable "memory-x"
      embassy-stm32 = { version = "0.3.0", features = [ "defmt", "unstable-pac", "stm32l412kb", "memory-x", "time-driver-any"]  }
      embassy-executor = { version = "0.8.0", features = ["arch-cortex-m", "executor-thread", "defmt"] }
      ```

   4. Test it with `cargo build` and `cargo run`
      1. Check what happens if you run `$env:DEFMT_LOG="debug"; cargo run`
   5. You may clone the repository again into a different location and checkout the branch `ox11/project_setup` to find inspiration for the next tasks
   6. Copy and edit `task.json` and `launch.json` launch from VS Code
3. Add a button that controls an led
   1. Init the hardware
   2. Configure your pins
   3. Use the button (jumper) and led
4. Change the led to blink
   1. Add `embassy-time` to the `Cargo.toml` file
   2. Use the async await function to blink
5. Read out the temperature of the sensor on a button press or periodically.
   1. ...

------------------------------------------------------------------------------

## Advanced Info

### Inspect Binary

inspect the elf header

```ps
cargo readobj --bin my_nucleo_rust_sensor -- --file-headers
```

inspect linker sections

```ps
cargo size --bin my_nucleo_rust_sensor -- -A
```